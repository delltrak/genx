package genx

import (
	"database/sql"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"

	"github.com/golang-jwt/jwt"
)

var (
	projet_name       string
	projet_author     string
	projet_version    string
	projet_build      string
	generator_name    string
	generator_version string

	jwt_secret string

	database_host string
	database_port string
	database_user string
	database_pass string
	database_name string
)

func SetProjectName(name string) {
	projet_name = name
}

func SetProjectAuthor(author string) {
	projet_author = author
}

func SetProjectVersion(version string) {
	projet_version = version
}

func SetProjectBuild(build string) {
	projet_build = build
}

func SetGeneratorName(name string) {
	generator_name = name
}

func SetGeneratorVersion(version string) {
	generator_version = version
}

func SetJwtSecret(secret string) {
	jwt_secret = secret
}

func SetDatabaseHost(host string) {
	database_host = host
}

func SetDatabasePort(port string) {
	database_port = port
}

func SetDatabaseUser(user string) {
	database_user = user
}

func SetDatabasePass(pass string) {
	database_pass = pass
}

func SetDatabaseName(name string) {
	database_name = name
}

/* --------------- LOG INITIALIZE --------------- */
func logInitialize() {

	// log blue color message welcome to projectName
	log.Printf("\033[35;1mWelcome to %s!\033[0m", projet_name)
	log.Printf("\033[30;1mAuthor %s!\033[0m", projet_author)
	log.Printf("\033[30mgenerated by %s\033[0m", generator_name+" "+generator_version)

	// log green color message version project version and build
	log.Printf("\033[30mproject version %s - build number %s\033[0m", projet_version, projet_build)
	log.Printf("\033[30m==============================================\033[0m")
}

/*
	SecureHandlerFunc is a middleware that checks if the request has a valid token

and if the token has the correct command claim
wich pass handlerFunc and secretKey as parameters
*/
func Secure(handlerFunc http.Handler) http.Handler {

	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {

		ip := r.RemoteAddr
		browser := r.UserAgent()
		method := r.Method
		path := r.URL.Path

		log.Printf("\033[30m==============================================\033[0m")
		log.Printf("\033[34;1mRequest: %s %s, IP: %s, Browser: %s\033[0m", method, path, ip, browser)

		// log body of the request
		bodyBytes, err := ioutil.ReadAll(r.Body)
		if err != nil {
			log.Fatal(err)
		}
		bodyString := string(bodyBytes)
		log.Printf("\033[30;1mBody: %s\033[0m", bodyString)

		// pega o bearer token
		bearerToken := r.Header.Get("Authorization")

		// verifica se o token estÃ¡ presente
		if bearerToken == "" {
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusUnauthorized)
			fmt.Fprintf(w, `{ "success": false, "message": "Token nÃ£o encontrado!" }`)
			// log in red color message token not found
			log.Printf("\033[31mðŸš¨ Bearer token not found, request was rejected!\033[0m")
			return
		}

		bearerToken = bearerToken[len("Bearer "):]

		// verifica se o token Ã© valido
		token, err := jwt.Parse(bearerToken, func(token *jwt.Token) (interface{}, error) {
			// verifica se o token Ã© valido
			if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {

				return nil, fmt.Errorf("Erro ao validar o token!")
			}
			return []byte(jwt_secret), nil
		})

		// verifica se o token Ã© valido
		if err != nil {

			// response in json
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusUnauthorized)
			log.Printf("\033[31mðŸš¨ Erro ao verificar token.\033[0m")
			fmt.Fprintf(w, `{ "success": false, "message": "Token invÃ¡lido!" }`)
			return
		}

		// verifica se o token Ã© valido
		if !token.Valid {

			// response in json
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusUnauthorized)
			log.Printf("\033[31mðŸš¨ Token invÃ¡lido.\033[0m")
			fmt.Fprintf(w, `{ "success": false, "message": "Token invÃ¡lido!" }`)
			return
		}

		/* // get claims
		claims, ok := token.Claims.(jwt.MapClaims)
		if !ok {
			log.Printf("\033[31mðŸš¨ Erro ao obter claims.\033[0m")
			return
		}

		command, ok := claims["command"].(string)
		if !ok {
			log.Println("Invalid or missing command claim")
			return
		}
		log.Printf("\033[32mCommand: %s\033[0m", command)*/

		// chama o proximo handler
		handlerFunc.ServeHTTP(w, r)
	})
}

/* --------------- DATABASE --------------- */
func connectMySQL() (*sql.DB, error) {

	// log yellow color message trying to connect to database
	log.Println("\033[33mTrying to connect to database...\033[0m")

	// print the user, db name on host in the port port in the grey color
	log.Printf("\033[30;1mIn %s with user %s at %s in the port %s\033[0m", database_name, database_user, database_host, database_port)

	dsn := fmt.Sprintf("%s:%s@tcp(%s)/%s?parseTime=true", database_user, database_pass, database_host, database_name)

	// Abre uma nova conexÃ£o com o banco de dados.
	db, err := sql.Open("mysql", dsn)
	if err != nil {
		// log in red
		log.Printf("\033[31mError to connect to database: %s\033[0m", err.Error())
		return nil, err
	}

	// Verifica a conexÃ£o com o banco de dados.
	err = db.Ping()
	if err != nil {
		// log in red color message error to connect to database
		log.Printf("\033[31mError to ping on database: %s\033[0m", err.Error())
		return nil, err
	}

	log.Println("\033[32mPing to database was successful!\033[0m")

	log.Println("\033[32mConnection established with database!\033[0m")
	return db, nil
}
